<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/custom.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

        <script type="text/javascript" src="node_modules/jquery/dist/jquery.js"></script>

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
                <section>
                    <h2>Parallelization of Constraint Programming using Embarrassingly Parallel Search</h2>
                    Guillaume Derval<br/>
                    June 24th 2016
                </section>
                <!--<section>
                    <h3>Cloud is everywhere</h3>
                    <script type="text/javascript" src="//www.google.com/trends/embed.js?hl=en&q=/m/02y_9m3,+/m/0jgqg&cmpt=q&tz=Etc/GMT-2&tz=Etc/GMT-2&content=1&cid=TIMESERIES_GRAPH_0&export=5&w=500&h=330"></script>
                </section>
                <section>
                    <h3>Virtually unlimited distributed power</h3>
                    Amazon Web Services (in 2014): 2 000 000 servers<br/>
                    Usage increase: 132% YoY<br/>
                    <br/>
                    Microsoft (in 2015): 1 000 000 servers<br/>
                    <br/>
                    Google : something in between
                </section>-->
                <section>
                    <h3>Contents</h3>
                    <ul>
                        <li>CP, Parallel and Distributed Computing in 120 seconds</li>
                        <li>Distributing CP</li>
                        <li>Decompositions</li>
                        <li>OscaR-Modeling - DSL</li>
                        <li>OscaR-Modeling - Architecture</li>
                    </ul>
                </section>
                <section><h2>CP, Parallel and Distributed Computing in 120 seconds</h2></section>
                <section>
                    <h3>Constraint programming</h3>
                    To cite Eugene Freuder (in its famous paper In Pursuit of the Holy Grail):
                    <blockquote>
                        &ldquo;Constraint Programming represents one of the closest approaches computer science has yet
                        made to the Holy Grail of programming: the user states the problem, the computer solves it.&rdquo;
                    </blockquote>
                </section>
                <section>
                    <h3>Constraint programming(2)</h3>
                    <ul>
                        <li>Given a CSP/COP</li>
                        <li>Visit the "whole" search space</li>
                        <li>Cut in the tree using "constraints"</li>
                    </ul>
                </section>
                <section>
                    <h3>Serial, Parallel, Distributed computing</h3>
                    <img src="img/spd.svg" style="border:none; box-shadow: none; background: transparent"/>
                </section>
                <section>
                    <h3>Speedup and efficiency</h3>
                    <h4>Speedup $S$ (in latency):</h4>
                    Ratio between the time taken to run on the "old" arch., and the time on the "new" one.
                    <br/>
                    <br/>
                    <h4>Efficiency $\eta$:</h4>
                    Speedup divided by the number of threads/cores/workers involved.
                </section>
				<section><h1>Distributing CP</h1></section>
                <section>
                    <h3>Static Decomposition</h3>
                    <ul>
                        <li class="fragment">Divide the initial problem</li>
                        <li class="fragment">S.t. each worker has a subproblem</li>
                        <li class="fragment">Decomposing is hard</li>
                    </ul>
                    <iframe data-src="static-decomposition.html" width="540px" height="400px" style="margin: auto;"></iframe>
                </section>
                <section>
                    <h3>Work-Stealing</h3>
                    <ul>
                        <li>Idle workers "steals" work</li>
                        <li class="fragment">Start with a single worker with the full problem</li>
                        <li class="fragment"><i>Idle</i> worker stop <i>solving</i> workers to ask for work</li>
                        <li class="fragment">Difficult to say when to stop</li>
                        <li class="fragment">Too much communication -> slow</li>
                    </ul>
                    <iframe data-src="work-stealing.html" width="712px" height="400px" style="margin: auto;"></iframe>
                </section>
                <section>
                    <h3>Embarassingly Parallel Search</h3>
                    <ul>
                        <li>Extension of Static Decomposition</li>
                        <li class="fragment">Numerous subproblems</li>
                        <li class="fragment">Static or dynamic assignation to worker</li>
                        <li class="fragment">More subproblems = better balancing</li>
                    </ul>
                    <iframe data-src="eps12.html" width="540px" height="400px" style="margin: auto;"></iframe>
                </section>
                <section>
                    <h2>Decompositions</h2>
                </section>
                <section>
                    <section>
                        <h3>Importance of decompositions</h3>
                        <br/>
                        <br/>
                        <p>
                            Given $t_{\text{max}}$, the solving time of the largest subproblem:
                        </p>
                        <ul>
                            <li>Minimum solving time is then $t_{\text{max}}$</li>
                            <li>The maximum inactivity time of any worker is $t_{\text{max}}$</li>
                        </ul>
                        <br/><br/><br/>
                        <h4>
                            Decompositions should minimize $t_{\text{max}}$.
                        </h4>
                    </section>
                    <section>
                        <h3>Decompositions on COPs</h3>
                        <br/>
                        <br/>
                        <p>For optimization problems</p>
                        <h4>More balanced subproblems = better chances to find the optimum rapidly</h4>
                    </section>
                </section>
                <section>
                    <section>
                        <h3>IDDFS</h3>
                        Iterative deepening DFS, subproblems are the nodes on the last depth visited.<br/>
                        <br/>
                        <ol>
                            <li>For maxDepth=1</li>
                            <li>Do a DFS up to depth maxDepth, keep frontier in memory</li>
                            <li>If frontier not big enough, increase maxDepth, start from 1</li>
                            <li>Return frontier as subproblems</li>
                        </ol>
                    </section>

                    <section>
                        <h3>Complexity</h3>
                        <p>For $n$ the number of subproblems and $b$ the branching factor:</p>
                        <ul>
                            <li>Time complexity: $\mathcal{O}(n)$</li>
                            <li>Space complexity: $\mathcal{O}(n)$</li>
                        </ul>

                        <p><small>NB: time complexity = number of calls to the fixed-point</small></p>
                    </section>
                    <section>
                        <h3>Good enough?</h3>
                        Implicit assumption: each node at the same height are +/- the same space size
                        <br/>
                        <br/>
                        <h4>In practice? False.</h4>
                        <img data-src="img/golomb_decomp_regin.png"/>
                    </section>
                </section>
                <section>
                    <section>
                        <h3>CPIR</h3>
                        Idea: iterative refinement + decompose bigger subproblems first.<br/>
                        <br/>
                        Bigger = greater Cartesian Product Cardinality<br/>
                        <br/>
                        <ol>
                            <li>Init a priority queue pq</li>
                            <li>Put the initial problem inside</li>
                            <li>While pq.size < threshold
                                <ol>
                                    <li>Get biggest subproblem</li>
                                    <li>Divide it</li>
                                    <li>Put new subproblems in the queue</li>
                                </ol>
                            </li>
                        </ol>
                    </section>
                    <section>
                        <h3>Complexity</h3>
                        <p>For $n$ the number of subproblems and $b$ the branching factor:</p>
                        <ul>
                            <li>Time complexity: $\mathcal{O}(n)$</li>
                            <li>Space complexity: $\mathcal{O}(n)$</li>
                        </ul>

                        <p><small>NB: time complexity = number of calls to the fixed-point.</small></p>
                    </section>
                    <section>
                        <h3>Good enough?</h3>
                        <img data-src="img/golomb_decomp_cpr_binary.png"/>
                    </section>
                </section>
                <section>
                    <h3>CPIR vs IDDFS</h3>
                    <img data-src="img/iddfs_vs_cpir.png"/>
                </section>
				<section data-background-video="video.mp4">Slide test</section>
				<section data-background-video="video.mp4">Slide test2</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,
                controls: true,
                transition: "convex",
                math: {
                    mathjax: 'https://cdn.mathjax.org/mathjax/latest/MathJax.js',
                    config: 'TeX-AMS_HTML-full'  // See http://docs.mathjax.org/en/latest/config-files.html
                },
				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/math/math.js', async: true },
                    { src: 'plugin/menu/menu.js' }
				],
                menu: {
                    side: 'left',
                    numbers: true,
                    titleSelector: 'h1, h2, h3, h4, h5, h6',
                    hideMissingTitles: false,
                    markers: true,
                    custom: false,
                    themes: [
                        { name: 'Black', theme: 'css/theme/black.css' },
                        { name: 'White', theme: 'css/theme/white.css' },
                        { name: 'League', theme: 'css/theme/league.css' },
                        { name: 'Sky', theme: 'css/theme/sky.css' },
                        { name: 'Beige', theme: 'css/theme/beige.css' },
                        { name: 'Simple', theme: 'css/theme/simple.css' },
                        { name: 'Serif', theme: 'css/theme/serif.css' },
                        { name: 'Blood', theme: 'css/theme/blood.css' },
                        { name: 'Night', theme: 'css/theme/night.css' },
                        { name: 'Moon', theme: 'css/theme/moon.css' },
                        { name: 'Solarized', theme: 'css/theme/solarized.css' },
                        { name: 'Custom', theme: 'css/theme/custom.css' }
                    ],
                    transitions: true,
                    openButton: true,
                    openSlideNumber: false,
                    keyboard: true
                }
			});

            Reveal.addEventListener( 'fragmentshown', function( event ) {
                var w = $("iframe", Reveal.getCurrentSlide())[0].contentWindow;
                w.postMessage("showFragment","*");
            } );
		</script>
	</body>
</html>
